[{"updatedAt":"2025-10-29T17:26:06.938Z","createdAt":"2025-10-28T04:33:50.805Z","id":"sLcbQX1bnXeEXHxN","name":"Generate Educational Content","active":true,"isArchived":false,"nodes":[{"parameters":{"options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[592,0],"id":"f8a4dca7-4393-49d0-8245-c155e37a5d81","name":"Respond to Webhook"},{"parameters":{"jsCode":"// Obtener la respuesta de Ollama\nconst ollamaResponse = $input.first().json;\nconst content = ollamaResponse.response;\n\n// Función auxiliar para extraer secciones\nfunction extractSection(text, startMarker, endMarker) {\n  const start = text.indexOf(startMarker);\n  if (start === -1) return '';\n  const afterStart = start + startMarker.length;\n  const end = endMarker ? text.indexOf(endMarker, afterStart) : text.length;\n  return text.substring(afterStart, end !== -1 ? end : text.length).trim();\n}\n\n// 1. PARSEAR FLASHCARDS\nconst flashcardsSection = extractSection(content, '### FLASHCARDS', '### MEMORIA');\nconst flashcards = [];\nconst flashcardLines = flashcardsSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of flashcardLines) {\n  const match = line.match(/P:\\s*(.+?)\\s*\\|\\s*R:\\s*(.+)/);\n  if (match) {\n    flashcards.push({\n      question: match[1].trim(),\n      answer: match[2].trim()\n    });\n  }\n}\n\n// 2. PARSEAR MEMORIA\nconst memoriaSection = extractSection(content, '### MEMORIA', '### RELACIONES');\nconst cardsMemory = [];\nconst memoriaLines = memoriaSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of memoriaLines) {\n  const parts = line.replace(/^\\d+\\.\\s*/, '').split('<->');\n  if (parts.length === 2) {\n    cardsMemory.push({\n      card1: parts[0].trim(),\n      card2: parts[1].trim(),\n      isMatched: true\n    });\n  }\n}\n\n// 3. PARSEAR RELACIONES\nconst relacionesSection = extractSection(content, '### RELACIONES', '### QUIZ');\nconst playRelations = [];\n\n// Parsear todas las líneas numeradas\nconst relacionesLines = relacionesSection.split('\\n');\nlet isCorrect = false;\n\nfor (const line of relacionesLines) {\n  if (line.includes('CORRECTAS:')) {\n    isCorrect = true;\n    continue;\n  }\n  if (line.includes('INCORRECTAS:')) {\n    isCorrect = false;\n    continue;\n  }\n  \n  if (line.match(/^\\d+\\./)) {\n    const parts = line.replace(/^\\d+\\.\\s*/, '').split('=');\n    if (parts.length === 2) {\n      playRelations.push({\n        item1: parts[0].trim(),\n        item2: parts[1].trim(),\n        isRelated: isCorrect\n      });\n    }\n  }\n}\n\n// 4. PARSEAR QUIZ\nconst quizSection = extractSection(content, '### QUIZ', null);\nconst quiz = [];\n\n// Dividir por líneas que empiezan con número\nconst quizBlocks = quizSection.split(/\\n(?=\\d+\\.)/);\n\nfor (const block of quizBlocks) {\n  if (!block.trim()) continue;\n  \n  const lines = block.split('\\n');\n  if (lines.length < 2) continue;\n  \n  // Extraer pregunta (primera línea)\n  const questionLine = lines[0].replace(/^\\d+\\.\\s*/, '').trim();\n  \n  // Extraer opciones de la segunda línea\n  const optionsLine = lines[1];\n  const optionMatches = optionsLine.match(/A\\)\\s*([^B]+)\\s*B\\)\\s*([^C]+)\\s*C\\)\\s*([^D]+)\\s*D\\)\\s*(.+?)(?:\\s*\\(|$)/);\n  \n  // Buscar respuesta\n  let correctOption = 'A';\n  const respuestaMatch = block.match(/Respuesta:\\s*([A-D])\\)/);\n  if (respuestaMatch) {\n    correctOption = respuestaMatch[1];\n  }\n  \n  if (optionMatches) {\n    quiz.push({\n      question: questionLine,\n      optionA: optionMatches[1].trim(),\n      optionB: optionMatches[2].trim(),\n      optionC: optionMatches[3].trim(),\n      optionD: optionMatches[4].trim(),\n      correctOption: correctOption\n    });\n  }\n}\n\n// DEVOLVER RESPUESTA ESTRUCTURADA\nreturn {\n  json: {\n    flashcards: flashcards.slice(0, 8),\n    cardsMemory: cardsMemory.slice(0, 6),\n    playRelations: playRelations.slice(0, 8),\n    quiz: quiz.slice(0, 7),\n    metadata: {\n      model: \"phi3\",\n      timestamp: new Date().toISOString(),\n      counts: {\n        flashcards: flashcards.length,\n        cardsMemory: cardsMemory.length,\n        playRelations: playRelations.length,\n        quiz: quiz.length\n      }\n    }\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[416,0],"id":"4925edbf-eb34-44fc-a5f3-0de5e4b61006","name":"Code in JavaScript"},{"parameters":{"options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[592,160],"id":"fdea3b18-9a1b-4d72-a835-11451ef62c71","name":"Respond to Webhook1"},{"parameters":{"jsCode":"// Obtener la respuesta de Ollama\nconst ollamaResponse = $input.first().json;\nconst content = ollamaResponse.response;\n\n// Función auxiliar para extraer secciones\nfunction extractSection(text, startMarker, endMarker) {\n  const start = text.indexOf(startMarker);\n  if (start === -1) return '';\n  const afterStart = start + startMarker.length;\n  const end = endMarker ? text.indexOf(endMarker, afterStart) : text.length;\n  return text.substring(afterStart, end !== -1 ? end : text.length).trim();\n}\n\n// 1. PARSEAR FLASHCARDS\nconst flashcardsSection = extractSection(content, '### FLASHCARDS', '### MEMORIA');\nconst flashcards = [];\nconst flashcardLines = flashcardsSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of flashcardLines) {\n  const match = line.match(/P:\\s*(.+?)\\s*\\|\\s*R:\\s*(.+)/);\n  if (match) {\n    flashcards.push({\n      question: match[1].trim(),\n      answer: match[2].trim()\n    });\n  }\n}\n\n// 2. PARSEAR MEMORIA\nconst memoriaSection = extractSection(content, '### MEMORIA', '### RELACIONES');\nconst cardsMemory = [];\nconst memoriaLines = memoriaSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of memoriaLines) {\n  const parts = line.replace(/^\\d+\\.\\s*/, '').split('<->');\n  if (parts.length === 2) {\n    cardsMemory.push({\n      card1: parts[0].trim(),\n      card2: parts[1].trim(),\n      isMatched: true\n    });\n  }\n}\n\n// 3. PARSEAR RELACIONES\nconst relacionesSection = extractSection(content, '### RELACIONES', '### QUIZ');\nconst playRelations = [];\n\n// Parsear todas las líneas numeradas\nconst relacionesLines = relacionesSection.split('\\n');\nlet isCorrect = false;\n\nfor (const line of relacionesLines) {\n  if (line.includes('CORRECTAS:')) {\n    isCorrect = true;\n    continue;\n  }\n  if (line.includes('INCORRECTAS:')) {\n    isCorrect = false;\n    continue;\n  }\n  \n  if (line.match(/^\\d+\\./)) {\n    const parts = line.replace(/^\\d+\\.\\s*/, '').split('=');\n    if (parts.length === 2) {\n      playRelations.push({\n        item1: parts[0].trim(),\n        item2: parts[1].trim(),\n        isRelated: isCorrect\n      });\n    }\n  }\n}\n\n// 4. PARSEAR QUIZ\nconst quizSection = extractSection(content, '### QUIZ', null);\nconst quiz = [];\n\n// Dividir por líneas que empiezan con número\nconst quizBlocks = quizSection.split(/\\n(?=\\d+\\.)/);\n\nfor (const block of quizBlocks) {\n  if (!block.trim()) continue;\n  \n  const lines = block.split('\\n');\n  if (lines.length < 2) continue;\n  \n  // Extraer pregunta (primera línea)\n  const questionLine = lines[0].replace(/^\\d+\\.\\s*/, '').trim();\n  \n  // Extraer opciones de la segunda línea\n  const optionsLine = lines[1];\n  const optionMatches = optionsLine.match(/A\\)\\s*([^B]+)\\s*B\\)\\s*([^C]+)\\s*C\\)\\s*([^D]+)\\s*D\\)\\s*(.+?)(?:\\s*\\(|$)/);\n  \n  // Buscar respuesta\n  let correctOption = 'A';\n  const respuestaMatch = block.match(/Respuesta:\\s*([A-D])\\)/);\n  if (respuestaMatch) {\n    correctOption = respuestaMatch[1];\n  }\n  \n  if (optionMatches) {\n    quiz.push({\n      question: questionLine,\n      optionA: optionMatches[1].trim(),\n      optionB: optionMatches[2].trim(),\n      optionC: optionMatches[3].trim(),\n      optionD: optionMatches[4].trim(),\n      correctOption: correctOption\n    });\n  }\n}\n\n// DEVOLVER RESPUESTA ESTRUCTURADA\nreturn {\n  json: {\n    flashcards: flashcards.slice(0, 8),\n    cardsMemory: cardsMemory.slice(0, 6),\n    playRelations: playRelations.slice(0, 8),\n    quiz: quiz.slice(0, 7),\n    metadata: {\n      model: \"phi3\",\n      timestamp: new Date().toISOString(),\n      counts: {\n        flashcards: flashcards.length,\n        cardsMemory: cardsMemory.length,\n        playRelations: playRelations.length,\n        quiz: quiz.length\n      }\n    }\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[416,160],"id":"1dd81310-25c1-4362-b432-63d8b1a7f91a","name":"Code in JavaScript1"},{"parameters":{"options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[592,304],"id":"3d371403-30cb-41ca-aea1-1837bdc55ced","name":"Respond to Webhook2"},{"parameters":{"jsCode":"// Obtener la respuesta de Ollama\nconst ollamaResponse = $input.first().json;\nconst content = ollamaResponse.response;\n\n// Función auxiliar para extraer secciones\nfunction extractSection(text, startMarker, endMarker) {\n  const start = text.indexOf(startMarker);\n  if (start === -1) return '';\n  const afterStart = start + startMarker.length;\n  const end = endMarker ? text.indexOf(endMarker, afterStart) : text.length;\n  return text.substring(afterStart, end !== -1 ? end : text.length).trim();\n}\n\n// 1. PARSEAR FLASHCARDS\nconst flashcardsSection = extractSection(content, '### FLASHCARDS', '### MEMORIA');\nconst flashcards = [];\nconst flashcardLines = flashcardsSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of flashcardLines) {\n  const match = line.match(/P:\\s*(.+?)\\s*\\|\\s*R:\\s*(.+)/);\n  if (match) {\n    flashcards.push({\n      question: match[1].trim(),\n      answer: match[2].trim()\n    });\n  }\n}\n\n// 2. PARSEAR MEMORIA\nconst memoriaSection = extractSection(content, '### MEMORIA', '### RELACIONES');\nconst cardsMemory = [];\nconst memoriaLines = memoriaSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of memoriaLines) {\n  const parts = line.replace(/^\\d+\\.\\s*/, '').split('<->');\n  if (parts.length === 2) {\n    cardsMemory.push({\n      card1: parts[0].trim(),\n      card2: parts[1].trim(),\n      isMatched: true\n    });\n  }\n}\n\n// 3. PARSEAR RELACIONES\nconst relacionesSection = extractSection(content, '### RELACIONES', '### QUIZ');\nconst playRelations = [];\n\n// Parsear todas las líneas numeradas\nconst relacionesLines = relacionesSection.split('\\n');\nlet isCorrect = false;\n\nfor (const line of relacionesLines) {\n  if (line.includes('CORRECTAS:')) {\n    isCorrect = true;\n    continue;\n  }\n  if (line.includes('INCORRECTAS:')) {\n    isCorrect = false;\n    continue;\n  }\n  \n  if (line.match(/^\\d+\\./)) {\n    const parts = line.replace(/^\\d+\\.\\s*/, '').split('=');\n    if (parts.length === 2) {\n      playRelations.push({\n        item1: parts[0].trim(),\n        item2: parts[1].trim(),\n        isRelated: isCorrect\n      });\n    }\n  }\n}\n\n// 4. PARSEAR QUIZ\nconst quizSection = extractSection(content, '### QUIZ', null);\nconst quiz = [];\n\n// Dividir por líneas que empiezan con número\nconst quizBlocks = quizSection.split(/\\n(?=\\d+\\.)/);\n\nfor (const block of quizBlocks) {\n  if (!block.trim()) continue;\n  \n  const lines = block.split('\\n');\n  if (lines.length < 2) continue;\n  \n  // Extraer pregunta (primera línea)\n  const questionLine = lines[0].replace(/^\\d+\\.\\s*/, '').trim();\n  \n  // Extraer opciones de la segunda línea\n  const optionsLine = lines[1];\n  const optionMatches = optionsLine.match(/A\\)\\s*([^B]+)\\s*B\\)\\s*([^C]+)\\s*C\\)\\s*([^D]+)\\s*D\\)\\s*(.+?)(?:\\s*\\(|$)/);\n  \n  // Buscar respuesta\n  let correctOption = 'A';\n  const respuestaMatch = block.match(/Respuesta:\\s*([A-D])\\)/);\n  if (respuestaMatch) {\n    correctOption = respuestaMatch[1];\n  }\n  \n  if (optionMatches) {\n    quiz.push({\n      question: questionLine,\n      optionA: optionMatches[1].trim(),\n      optionB: optionMatches[2].trim(),\n      optionC: optionMatches[3].trim(),\n      optionD: optionMatches[4].trim(),\n      correctOption: correctOption\n    });\n  }\n}\n\n// DEVOLVER RESPUESTA ESTRUCTURADA\nreturn {\n  json: {\n    flashcards: flashcards.slice(0, 8),\n    cardsMemory: cardsMemory.slice(0, 6),\n    playRelations: playRelations.slice(0, 8),\n    quiz: quiz.slice(0, 7),\n    metadata: {\n      model: \"phi3\",\n      timestamp: new Date().toISOString(),\n      counts: {\n        flashcards: flashcards.length,\n        cardsMemory: cardsMemory.length,\n        playRelations: playRelations.length,\n        quiz: quiz.length\n      }\n    }\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[416,304],"id":"e0c80674-87d2-415b-94c9-c1d8fab3638d","name":"Code in JavaScript2"},{"parameters":{"options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[592,464],"id":"575d2130-782c-455a-8817-2af17618e4a1","name":"Respond to Webhook3"},{"parameters":{"jsCode":"// Obtener la respuesta de Ollama\nconst ollamaResponse = $input.first().json;\nconst content = ollamaResponse.response;\n\n// Función auxiliar para extraer secciones\nfunction extractSection(text, startMarker, endMarker) {\n  const start = text.indexOf(startMarker);\n  if (start === -1) return '';\n  const afterStart = start + startMarker.length;\n  const end = endMarker ? text.indexOf(endMarker, afterStart) : text.length;\n  return text.substring(afterStart, end !== -1 ? end : text.length).trim();\n}\n\n// 1. PARSEAR FLASHCARDS\nconst flashcardsSection = extractSection(content, '### FLASHCARDS', '### MEMORIA');\nconst flashcards = [];\nconst flashcardLines = flashcardsSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of flashcardLines) {\n  const match = line.match(/P:\\s*(.+?)\\s*\\|\\s*R:\\s*(.+)/);\n  if (match) {\n    flashcards.push({\n      question: match[1].trim(),\n      answer: match[2].trim()\n    });\n  }\n}\n\n// 2. PARSEAR MEMORIA\nconst memoriaSection = extractSection(content, '### MEMORIA', '### RELACIONES');\nconst cardsMemory = [];\nconst memoriaLines = memoriaSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of memoriaLines) {\n  const parts = line.replace(/^\\d+\\.\\s*/, '').split('<->');\n  if (parts.length === 2) {\n    cardsMemory.push({\n      card1: parts[0].trim(),\n      card2: parts[1].trim(),\n      isMatched: true\n    });\n  }\n}\n\n// 3. PARSEAR RELACIONES\nconst relacionesSection = extractSection(content, '### RELACIONES', '### QUIZ');\nconst playRelations = [];\n\n// Parsear todas las líneas numeradas\nconst relacionesLines = relacionesSection.split('\\n');\nlet isCorrect = false;\n\nfor (const line of relacionesLines) {\n  if (line.includes('CORRECTAS:')) {\n    isCorrect = true;\n    continue;\n  }\n  if (line.includes('INCORRECTAS:')) {\n    isCorrect = false;\n    continue;\n  }\n  \n  if (line.match(/^\\d+\\./)) {\n    const parts = line.replace(/^\\d+\\.\\s*/, '').split('=');\n    if (parts.length === 2) {\n      playRelations.push({\n        item1: parts[0].trim(),\n        item2: parts[1].trim(),\n        isRelated: isCorrect\n      });\n    }\n  }\n}\n\n// 4. PARSEAR QUIZ\nconst quizSection = extractSection(content, '### QUIZ', null);\nconst quiz = [];\n\n// Dividir por líneas que empiezan con número\nconst quizBlocks = quizSection.split(/\\n(?=\\d+\\.)/);\n\nfor (const block of quizBlocks) {\n  if (!block.trim()) continue;\n  \n  const lines = block.split('\\n');\n  if (lines.length < 2) continue;\n  \n  // Extraer pregunta (primera línea)\n  const questionLine = lines[0].replace(/^\\d+\\.\\s*/, '').trim();\n  \n  // Extraer opciones de la segunda línea\n  const optionsLine = lines[1];\n  const optionMatches = optionsLine.match(/A\\)\\s*([^B]+)\\s*B\\)\\s*([^C]+)\\s*C\\)\\s*([^D]+)\\s*D\\)\\s*(.+?)(?:\\s*\\(|$)/);\n  \n  // Buscar respuesta\n  let correctOption = 'A';\n  const respuestaMatch = block.match(/Respuesta:\\s*([A-D])\\)/);\n  if (respuestaMatch) {\n    correctOption = respuestaMatch[1];\n  }\n  \n  if (optionMatches) {\n    quiz.push({\n      question: questionLine,\n      optionA: optionMatches[1].trim(),\n      optionB: optionMatches[2].trim(),\n      optionC: optionMatches[3].trim(),\n      optionD: optionMatches[4].trim(),\n      correctOption: correctOption\n    });\n  }\n}\n\n// DEVOLVER RESPUESTA ESTRUCTURADA\nreturn {\n  json: {\n    flashcards: flashcards.slice(0, 8),\n    cardsMemory: cardsMemory.slice(0, 6),\n    playRelations: playRelations.slice(0, 8),\n    quiz: quiz.slice(0, 7),\n    metadata: {\n      model: \"phi3\",\n      timestamp: new Date().toISOString(),\n      counts: {\n        flashcards: flashcards.length,\n        cardsMemory: cardsMemory.length,\n        playRelations: playRelations.length,\n        quiz: quiz.length\n      }\n    }\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[416,464],"id":"f420ab67-a0c0-40b2-a4de-ad30ac9ba1b9","name":"Code in JavaScript3"},{"parameters":{"options":{}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[592,640],"id":"3c7fc8ab-598b-4858-8ffe-31c9dfe47b60","name":"Respond to Webhook4"},{"parameters":{"jsCode":"// Obtener la respuesta de Ollama\nconst ollamaResponse = $input.first().json;\nconst content = ollamaResponse.response;\n\n// Función auxiliar para extraer secciones\nfunction extractSection(text, startMarker, endMarker) {\n  const start = text.indexOf(startMarker);\n  if (start === -1) return '';\n  const afterStart = start + startMarker.length;\n  const end = endMarker ? text.indexOf(endMarker, afterStart) : text.length;\n  return text.substring(afterStart, end !== -1 ? end : text.length).trim();\n}\n\n// 1. PARSEAR FLASHCARDS\nconst flashcardsSection = extractSection(content, '### FLASHCARDS', '### MEMORIA');\nconst flashcards = [];\nconst flashcardLines = flashcardsSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of flashcardLines) {\n  const match = line.match(/P:\\s*(.+?)\\s*\\|\\s*R:\\s*(.+)/);\n  if (match) {\n    flashcards.push({\n      question: match[1].trim(),\n      answer: match[2].trim()\n    });\n  }\n}\n\n// 2. PARSEAR MEMORIA\nconst memoriaSection = extractSection(content, '### MEMORIA', '### RELACIONES');\nconst cardsMemory = [];\nconst memoriaLines = memoriaSection.split('\\n').filter(line => line.match(/^\\d+\\./));\n\nfor (const line of memoriaLines) {\n  const parts = line.replace(/^\\d+\\.\\s*/, '').split('<->');\n  if (parts.length === 2) {\n    cardsMemory.push({\n      card1: parts[0].trim(),\n      card2: parts[1].trim(),\n      isMatched: true\n    });\n  }\n}\n\n// 3. PARSEAR RELACIONES\nconst relacionesSection = extractSection(content, '### RELACIONES', '### QUIZ');\nconst playRelations = [];\n\n// Parsear todas las líneas numeradas\nconst relacionesLines = relacionesSection.split('\\n');\nlet isCorrect = false;\n\nfor (const line of relacionesLines) {\n  if (line.includes('CORRECTAS:')) {\n    isCorrect = true;\n    continue;\n  }\n  if (line.includes('INCORRECTAS:')) {\n    isCorrect = false;\n    continue;\n  }\n  \n  if (line.match(/^\\d+\\./)) {\n    const parts = line.replace(/^\\d+\\.\\s*/, '').split('=');\n    if (parts.length === 2) {\n      playRelations.push({\n        item1: parts[0].trim(),\n        item2: parts[1].trim(),\n        isRelated: isCorrect\n      });\n    }\n  }\n}\n\n// 4. PARSEAR QUIZ\nconst quizSection = extractSection(content, '### QUIZ', null);\nconst quiz = [];\n\n// Dividir por líneas que empiezan con número\nconst quizBlocks = quizSection.split(/\\n(?=\\d+\\.)/);\n\nfor (const block of quizBlocks) {\n  if (!block.trim()) continue;\n  \n  const lines = block.split('\\n');\n  if (lines.length < 2) continue;\n  \n  // Extraer pregunta (primera línea)\n  const questionLine = lines[0].replace(/^\\d+\\.\\s*/, '').trim();\n  \n  // Extraer opciones de la segunda línea\n  const optionsLine = lines[1];\n  const optionMatches = optionsLine.match(/A\\)\\s*([^B]+)\\s*B\\)\\s*([^C]+)\\s*C\\)\\s*([^D]+)\\s*D\\)\\s*(.+?)(?:\\s*\\(|$)/);\n  \n  // Buscar respuesta\n  let correctOption = 'A';\n  const respuestaMatch = block.match(/Respuesta:\\s*([A-D])\\)/);\n  if (respuestaMatch) {\n    correctOption = respuestaMatch[1];\n  }\n  \n  if (optionMatches) {\n    quiz.push({\n      question: questionLine,\n      optionA: optionMatches[1].trim(),\n      optionB: optionMatches[2].trim(),\n      optionC: optionMatches[3].trim(),\n      optionD: optionMatches[4].trim(),\n      correctOption: correctOption\n    });\n  }\n}\n\n// DEVOLVER RESPUESTA ESTRUCTURADA\nreturn {\n  json: {\n    flashcards: flashcards.slice(0, 8),\n    cardsMemory: cardsMemory.slice(0, 6),\n    playRelations: playRelations.slice(0, 8),\n    quiz: quiz.slice(0, 7),\n    metadata: {\n      model: \"phi3\",\n      timestamp: new Date().toISOString(),\n      counts: {\n        flashcards: flashcards.length,\n        cardsMemory: cardsMemory.length,\n        playRelations: playRelations.length,\n        quiz: quiz.length\n      }\n    }\n  }\n};"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[416,640],"id":"a09b0e27-85de-41e3-b14e-49bfff3d8190","name":"Code in JavaScript4"},{"parameters":{"method":"POST","url":"http://ollama:11434/api/generate","sendBody":true,"specifyBody":"json","jsonBody":"={\n    \"model\": \"gemma2:2b\",\n    \"prompt\": \"Eres un asistente educativo especializado en crear pares de memoria para juegos educativos.\\n\\nCURSO: {{ $json.body.courseName }}\\nTEMA: {{ $json.body.topic }}\\nCONTEXTO: {{ $json.body.context }}\\nCANTIDAD: {{ $json.body.quantity }} pares\\n\\nOBJETIVO: Generar pares de términos relacionados que los estudiantes puedan asociar en un juego de memoria.\\n\\nREQUERIMIENTOS:\\n- Generar EXACTAMENTE {{ $json.body.quantity }} pares de memoria\\n- Cada par debe relacionar un concepto con su definición, ejemplo o equivalente\\n- Las relaciones deben ser claras e inequívocas\\n- Usar vocabulario apropiado para el nivel educativo\\n\\nFORMATO DE RESPUESTA JSON:\\n{\\n  \\\"cardsMemory\\\": [\\n    { \\\"card1\\\": \\\"Término o concepto\\\", \\\"card2\\\": \\\"Definición simple o equivalente\\\" }\\n  ]\\n}\\n\\nDESARROLLA LOS PARES DE MEMORIA AHORA.\",\n    \"stream\": false,\n    \"options\": {\n        \"num_predict\": 1500,\n        \"temperature\": 0.5\n    }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[208,160],"id":"9f1a4a37-bee4-4847-b0ea-d06d34cbae4d","name":"PARES DE MEMORIA"},{"parameters":{"method":"POST","url":"http://ollama:11434/api/generate","sendBody":true,"specifyBody":"json","jsonBody":"={\n    \"model\": \"gemma2:2b\",\n    \"prompt\": \"Eres un asistente educativo especializado en crear ejercicios de relaciones entre conceptos.\\n\\nCURSO: {{ $json.body.courseName }}\\nTEMA: {{ $json.body.topic }}\\nCONTEXTO: {{ $json.body.context }}\\nCORRECTAS: {{ $json.body.correctCount }} relaciones\\nINCORRECTAS: {{ $json.body.incorrectCount }} relaciones\\n\\nOBJETIVO: Generar relaciones entre conceptos para que los estudiantes identifiquen cuáles son correctas e incorrectas.\\n\\nREQUERIMIENTOS:\\n- Generar EXACTAMENTE {{ $json.body.correctCount }} relaciones CORRECTAS\\n- Generar EXACTAMENTE {{ $json.body.incorrectCount }} relaciones INCORRECTAS\\n- Las relaciones incorrectas deben ser plausibles para desafiar al estudiante\\n\\nFORMATO DE RESPUESTA JSON:\\n{\\n  \\\"playRelations\\\": [\\n    { \\\"item1\\\": \\\"Elemento A\\\", \\\"item2\\\": \\\"Elemento B\\\", \\\"isCorrect\\\": true },\\n    { \\\"item1\\\": \\\"Concepto X\\\", \\\"item2\\\": \\\"Concepto Z\\\", \\\"isCorrect\\\": false }\\n  ]\\n}\\n\\nNOTA: Las primeras {{ $json.body.correctCount }} deben tener isCorrect: true, las últimas {{ $json.body.incorrectCount }} deben tener isCorrect: false.\\n\\nDESARROLLA LAS RELACIONES AHORA.\",\n    \"stream\": false,\n    \"options\": {\n        \"num_predict\": 2000,\n        \"temperature\": 0.5\n    }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[208,304],"id":"c10f137c-9100-46da-ad45-56cbdcced118","name":"Generación de relaciones"},{"parameters":{"method":"POST","url":"http://ollama:11434/api/generate","sendBody":true,"specifyBody":"json","jsonBody":"={\n    \"model\": \"gemma2:2b\",\n    \"prompt\": \"Eres un asistente educativo especializado en crear contenido completo para actividades educativas.\\n\\nCURSO: {{ $json.body.courseName }}\\nTEMA: {{ $json.body.topic }}\\nCONTEXTO: {{ $json.body.context }}\\nMÍNIMO DE ITEMS: {{ $json.body.minItems }}\\n\\nOBJETIVO: Generar contenido educativo completo incluyendo flashcards, pares de memoria, relaciones y preguntas de quiz.\\n\\nREQUERIMIENTOS:\\n- Generar AL MENOS {{ $json.body.minItems }} elementos de cada tipo\\n- Adaptar el lenguaje al nivel educativo del curso\\n- Todo el contenido debe estar relacionado con el tema\\n\\nFORMATO DE RESPUESTA JSON:\\n{\\n  \\\"flashcards\\\": [\\n    { \\\"question\\\": \\\"¿Pregunta?\\\", \\\"answer\\\": \\\"Respuesta\\\" }\\n  ],\\n  \\\"cardsMemory\\\": [\\n    { \\\"card1\\\": \\\"Término\\\", \\\"card2\\\": \\\"Definición\\\" }\\n  ],\\n  \\\"playRelations\\\": [\\n    { \\\"item1\\\": \\\"Elemento A\\\", \\\"item2\\\": \\\"Elemento B\\\", \\\"isCorrect\\\": true }\\n  ],\\n  \\\"quiz\\\": {\\n    \\\"questions\\\": [\\n      {\\n        \\\"question\\\": \\\"¿Pregunta?\\\",\\n        \\\"optionA\\\": \\\"A\\\",\\n        \\\"optionB\\\": \\\"B\\\",\\n        \\\"optionC\\\": \\\"C\\\",\\n        \\\"optionD\\\": \\\"D\\\",\\n        \\\"correctOption\\\": \\\"B\\\"\\n      }\\n    ],\\n    \\\"questionsOpen\\\": [\\n      { \\\"question\\\": \\\"¿Pregunta abierta?\\\", \\\"answer\\\": \\\"Respuesta modelo\\\" }\\n    ]\\n  }\\n}\\n\\nDESARROLLA EL CONTENIDO COMPLETO AHORA.\",\n    \"stream\": false,\n    \"options\": {\n        \"num_predict\": 5000,\n        \"temperature\": 0.6\n    }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[208,640],"id":"e5b9e863-c3d0-4ead-9e17-4d4837995663","name":"Todas las activiades"},{"parameters":{"httpMethod":"POST","path":"generate-relations","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[0,304],"id":"91e4ba79-9f16-4e56-954e-69c476a91416","name":"Relaciones","webhookId":"7f0ac4ad-7a68-46db-87c8-3a77cfc4de9c"},{"parameters":{"httpMethod":"POST","path":"generate-quiz","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[0,464],"id":"07bcb7b3-e972-49ff-bd17-150603a672c7","name":"Quiz","webhookId":"7f0ac4ad-7a68-46db-87c8-3a77cfc4de9c"},{"parameters":{"httpMethod":"POST","path":"generate-content","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[0,640],"id":"c0235bc2-4d7f-4a52-9413-d03634a06731","name":"Todo","webhookId":"7f0ac4ad-7a68-46db-87c8-3a77cfc4de9c"},{"parameters":{"httpMethod":"POST","path":"generate-flashcards","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[0,0],"id":"daa8ec1f-7b97-4dc9-a1f9-c5ad37d930c0","name":"Flashcards","webhookId":"7f0ac4ad-7a68-46db-87c8-3a77cfc4de9c"},{"parameters":{"httpMethod":"POST","path":"generate-memory-pairs","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2.1,"position":[0,160],"id":"88e87433-8792-44cf-9541-e53469dd593d","name":"Memoria","webhookId":"7f0ac4ad-7a68-46db-87c8-3a77cfc4de9c"},{"parameters":{"method":"POST","url":"http://ollama:11434/api/generate","sendBody":true,"specifyBody":"json","jsonBody":"={\n    \"model\": \"gemma2:2b\",\n    \"prompt\": \"Eres un asistente educativo especializado en crear flashcards educativas.\\n\\nCURSO: {{ $json.body.courseName }}\\nTEMA: {{ $json.body.topic }}\\nCONTEXTO: {{ $json.body.context }}\\nCANTIDAD: {{ $json.body.quantity }} flashcards\\n\\nOBJETIVO: Generar flashcards que ayuden a memorizar y comprender conceptos clave.\\n\\nREQUERIMIENTOS:\\n- Generar EXACTAMENTE {{ $json.body.quantity }} flashcards\\n- Cada flashcard debe tener una pregunta clara y una respuesta concisa\\n- Incluir ejemplos o contexto cuando sea necesario\\n- Adaptar el lenguaje al nivel educativo del curso\\n\\nFORMATO DE RESPUESTA JSON:\\n{\\n  \\\"flashcards\\\": [\\n    { \\\"question\\\": \\\"¿Pregunta directa sobre el concepto?\\\", \\\"answer\\\": \\\"Respuesta clara con ejemplo si es necesario\\\" },\\n    { \\\"question\\\": \\\"¿Pregunta sobre aplicación?\\\", \\\"answer\\\": \\\"Respuesta explicativa\\\" }\\n  ]\\n}\\n\\nDESARROLLA LAS FLASHCARDS AHORA.\",\n    \"stream\": false,\n    \"options\": {\n        \"num_predict\": 2000,\n        \"temperature\": 0.6\n    }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[208,0],"id":"c6259f8b-6aa8-4a5f-a030-8e2a95559dce","name":"Generar Flashcards"},{"parameters":{"method":"POST","url":"http://ollama:11434/api/generate","sendBody":true,"specifyBody":"json","jsonBody":"={\n    \"model\": \"gemma2:2b\",\n    \"prompt\": \"Eres un asistente educativo especializado en crear preguntas de evaluación.\\n\\nCURSO: {{ $json.body.courseName }}\\nTEMA: {{ $json.body.topic }}\\nCONTEXTO: {{ $json.body.context }}\\nPREGUNTAS OPCIÓN MÚLTIPLE: {{ $json.body.multipleChoiceCount }}\\nPREGUNTAS ABIERTAS: {{ $json.body.openQuestionsCount }}\\n\\nOBJETIVO: Generar preguntas de quiz con opciones múltiples y preguntas abiertas.\\n\\nREQUERIMIENTOS:\\n- Generar EXACTAMENTE {{ $json.body.multipleChoiceCount }} preguntas de opción múltiple (4 opciones: A, B, C, D)\\n- Generar EXACTAMENTE {{ $json.body.openQuestionsCount }} preguntas abiertas con respuesta modelo\\n- Solo una opción es correcta en las de opción múltiple\\n- Los distractores deben ser plausibles\\n- Las preguntas abiertas deben requerir análisis y reflexión\\n\\nFORMATO DE RESPUESTA JSON:\\n{\\n  \\\"quiz\\\": {\\n    \\\"questions\\\": [\\n      {\\n        \\\"question\\\": \\\"¿Pregunta sobre el concepto?\\\",\\n        \\\"optionA\\\": \\\"Opción A\\\",\\n        \\\"optionB\\\": \\\"Opción B (correcta)\\\",\\n        \\\"optionC\\\": \\\"Opción C\\\",\\n        \\\"optionD\\\": \\\"Opción D\\\",\\n        \\\"correctOption\\\": \\\"B\\\"\\n      }\\n    ],\\n    \\\"questionsOpen\\\": [\\n      {\\n        \\\"question\\\": \\\"¿Pregunta que requiere explicación detallada?\\\",\\n        \\\"answer\\\": \\\"Respuesta modelo completa con: definición, explicación, ejemplo\\\"\\n      }\\n    ]\\n  }\\n}\\n\\nDESARROLLA LAS PREGUNTAS AHORA.\",\n    \"stream\": false,\n    \"options\": {\n        \"num_predict\": 3000,\n        \"temperature\": 0.5\n    }\n}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.3,"position":[208,464],"id":"9a233847-8878-4010-9dad-4f7ecda9dc21","name":"Generar preguntas quiz"}],"connections":{"Code in JavaScript":{"main":[[{"node":"Respond to Webhook","type":"main","index":0}]]},"Code in JavaScript1":{"main":[[{"node":"Respond to Webhook1","type":"main","index":0}]]},"Code in JavaScript2":{"main":[[{"node":"Respond to Webhook2","type":"main","index":0}]]},"Code in JavaScript3":{"main":[[{"node":"Respond to Webhook3","type":"main","index":0}]]},"Code in JavaScript4":{"main":[[{"node":"Respond to Webhook4","type":"main","index":0}]]},"PARES DE MEMORIA":{"main":[[{"node":"Code in JavaScript1","type":"main","index":0}]]},"Generación de relaciones":{"main":[[{"node":"Code in JavaScript2","type":"main","index":0}]]},"Todas las activiades":{"main":[[{"node":"Code in JavaScript4","type":"main","index":0}]]},"Relaciones":{"main":[[{"node":"Generación de relaciones","type":"main","index":0}]]},"Quiz":{"main":[[{"node":"Generar preguntas quiz","type":"main","index":0}]]},"Todo":{"main":[[{"node":"Todas las activiades","type":"main","index":0}]]},"Flashcards":{"main":[[{"node":"Generar Flashcards","type":"main","index":0}]]},"Memoria":{"main":[[{"node":"PARES DE MEMORIA","type":"main","index":0}]]},"Generar Flashcards":{"main":[[{"node":"Code in JavaScript","type":"main","index":0}]]},"Generar preguntas quiz":{"main":[[{"node":"Code in JavaScript3","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{},"versionId":"5d09f5bc-8635-4250-838f-4a3c8cbce8ea","triggerCount":5,"tags":[],"shared":[{"updatedAt":"2025-10-28T04:33:50.805Z","createdAt":"2025-10-28T04:33:50.805Z","role":"workflow:owner","workflowId":"sLcbQX1bnXeEXHxN","projectId":"zKUMyuq47NXmKr1F","project":{"updatedAt":"2025-10-28T04:33:03.530Z","createdAt":"2025-10-28T00:56:09.117Z","id":"zKUMyuq47NXmKr1F","name":"JOSHEP ANTONY Ccahuana <joshep.antony.cc.l@gmail.com>","type":"personal","icon":null,"description":null}}]}]
